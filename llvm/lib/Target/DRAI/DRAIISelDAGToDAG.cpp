//===-- DRAIISelDAGToDAG.cpp - A dag to dag inst selector for DRAI --------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the DRAI target.
//
//===----------------------------------------------------------------------===//

#include "DRAITargetMachine.h"
//#include "DRAIISelLowering.h"
#include "DRAI.h"
#include "llvm/Analysis/AliasAnalysis.h"
#include "llvm/CodeGen/FunctionLoweringInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/IntrinsicsDRAI.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/KnownBits.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "drai-isel"

namespace {

class DRAIDAGToDAGISel : public SelectionDAGISel {
  const DRAISubtarget *Subtarget;

  const DRAITargetMachine &getTargetMachine() const {
    return static_cast<const DRAITargetMachine &>(TM);
  }

  const DRAIInstrInfo *getInstrInfo() const {
   return Subtarget->getInstrInfo();
  }

  bool SelectConstant(SDNode *Node);
  bool SelectConstantFP(SDNode *Node);
  bool SelectBUILD_VECTOR(SDNode *Node);
  bool SelectSHL(SDNode *Node);
  bool SelectSRL(SDNode *Node);
  bool SelectZERO_EXTEND(SDNode *Node);
  bool SelectTRUNCATE(SDNode *Node);

  static char ID;

public:
  DRAIDAGToDAGISel(DRAITargetMachine &TM, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(ID, TM, OptLevel) {}


  bool runOnMachineFunction(MachineFunction &MF) override {
    Subtarget = &MF.getSubtarget<DRAISubtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

  // Override MachineFunctionPass.
  StringRef getPassName() const override {
    return "DRAI DAG->DAG Pattern Instruction Selection";
  }

  // Override SelectionDAGISel.
  void Select(SDNode *Node) override;

  // bool SelectADDRri(SDValue N, SDValue &Base, SDValue &Offset);
/*
bool SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID,
                                  std::vector<SDValue> &OutOps) override;
bool IsProfitableToFold(SDValue N, SDNode *U, SDNode *Root) const override;
void PreprocessISelDAG() override;
*/

// Include the pieces autogenerated from the target description.
#include "DRAIGenDAGISel.inc"
};
} // end anonymous namespace

char DRAIDAGToDAGISel::ID = 0;

FunctionPass *llvm::createDRAIISelDag(DRAITargetMachine &TM,
                                      CodeGenOpt::Level OptLevel) {
  return new DRAIDAGToDAGISel(TM, OptLevel);
}

/*
bool DRAIDAGToDAGISel::SelectConstant(SDNode *Node) {
  SDLoc dl(Node);

  EVT type = Node->getValueType(0);
  if (type != MVT::i64) {
    return false;
  }

  // lowering to MoveI + MoveES
  ConstantSDNode *c = cast<ConstantSDNode>(Node);
  int64_t val = c->getSExtValue();
  if (val < std::numeric_limits<int>::min() ||
      val > std::numeric_limits<int>::max()) {
    llvm_unreachable("constant value exceeded int value range!");
  }
  SDNode *r32 =
      CurDAG->getMachineNode(DRAI::MoveI_move_si, dl, MVT::i32,
                             CurDAG->getTargetConstant(val, dl, MVT::i32));
  SDNode *r64 = CurDAG->getMachineNode(DRAI::CastS_cast_i64_i32, dl,
                                       MVT::i64, SDValue(r32, 0));
  ReplaceNode(Node, r64);
  CurDAG->RemoveDeadNodes();
  return true;
}

bool DRAIDAGToDAGISel::SelectConstantFP(SDNode *Node) {
  SDLoc dl(Node);
  assert(isa<ConstantFPSDNode>(Node));
  APFloat fp = cast<ConstantFPSDNode>(Node)->getValueAPF();
  uint64_t imm = fp.bitcastToAPInt().getZExtValue();
  SDNode *move = CurDAG->getMachineNode(
      DRAI::MoveI_move_si, dl, MVT::f32, CurDAG->getTargetConstant(imm, dl, MVT::i32));
  ReplaceNode(Node, move);
  CurDAG->RemoveDeadNodes();
  return true;
}
*/

bool DRAIDAGToDAGISel::SelectBUILD_VECTOR(SDNode *Node) {
  SDLoc dl(Node);
  assert(isa<BuildVectorSDNode>(Node));
  BuildVectorSDNode *BVN = cast<BuildVectorSDNode>(Node);

  // check input is scalar
  SDValue first = BVN->getOperand(0);
  EVT VT = first->getValueType(0);
  if (VT != MVT::i32 && VT != MVT::f32 && VT != MVT::f16 && VT != MVT::i1) {
    dbgs() << "SelectBUILD_VECTOR: input operand not is scalar or pred!!\n";
    return false;
  }

  // check duplicate of the scalar
  int num = BVN->getNumOperands();
  for (int i = 1; i < num; ++i) {
    if (BVN->getOperand(i) != first) {
      dbgs() << "SelectBUILD_VECTOR: operand not is same reference!!\n";
      return false;
    }
  }

  SDNode *result = nullptr;
  EVT type = Node->getValueType(0);
  SDValue truth = CurDAG->getRegister(DRAI::PredTruth, Subtarget->Vec(MVT::i1));
  SDValue undef =
      SDValue(CurDAG->getMachineNode(TargetOpcode::IMPLICIT_DEF, dl, type), 0);
  if (VT == MVT::i1) {
    assert(isa<ConstantSDNode>(first));
    uint64_t value = cast<ConstantSDNode>(first)->getZExtValue();
    if (value == 1) {
      result = truth.getNode();
    } else if (value == 0) {
      result = CurDAG->getMachineNode(DRAI::ArithP_xor_p, dl, type,
                                      {truth, truth, truth, undef});
    } else {
      llvm_unreachable("unexpect BUILD_VECTOR input value!!\n");
    }
  } else {
    result = CurDAG->getMachineNode(DRAI::MoveV_move_vs, dl, type, first, truth,
                                    undef);
  }

  ReplaceNode(Node, result);
  CurDAG->RemoveDeadNodes();
  return true;
}

bool DRAIDAGToDAGISel::SelectSHL(SDNode *Node) {
  dbgs() << "hit: SelectSHL!!!\n";

  EVT type = Node->getValueType(0);
  if (type != MVT::i64) {
    return false;
  }
  SDValue input = Node->getOperand(0);
  SDValue val = Node->getOperand(1);
  if (val->getOpcode() != ISD::Constant) {
    llvm_unreachable("unexpected shl value");
  }

  ConstantSDNode *c = cast<ConstantSDNode>(val.getNode());
  int64_t cv = c->getConstantIntValue()->getSExtValue();
  if (cv < 0 || cv >= 40) {
    llvm_unreachable("unexpected shl value");
  }

  SDLoc dl(Node);
  SDValue new_c = CurDAG->getTargetConstant((1LL << cv), dl, MVT::i64);
  SDNode *imm =
      CurDAG->getMachineNode(DRAI::MoveI_move_ei, dl, MVT::i64, new_c);
  SDNode *mul = CurDAG->getMachineNode(DRAI::ArithE_mul_i64, dl, type, input,
                                       SDValue(imm, 0));

  ReplaceNode(Node, mul);
  CurDAG->RemoveDeadNodes();
  return true;
}

bool DRAIDAGToDAGISel::SelectSRL(SDNode *Node) {
  dbgs() << "hit: SelectSRL!!!\n";

  EVT type = Node->getValueType(0);
  if (type != MVT::i32) {
    return false;
  }
  SDValue input = Node->getOperand(0);
  SDValue val = Node->getOperand(1);

  // RegisterSDNode *rs = dyn_cast<RegisterSDNode>(val->getOperand(1));
  // Register reg = rs->getReg();
  // const llvm::Value *vvv = FuncInfo->getValueFromVirtualReg(reg);
  // MachineInstr *splat = RegInfo->getVRegDef(reg);
  // MachineInstr *right = RegInfo->getVRegDef(splat->getOperand(1).getReg());

  if (val->getOpcode() != ISD::Constant) {
    return false;
  }

  ConstantSDNode *c = cast<ConstantSDNode>(val.getNode());
  int64_t cv = c->getConstantIntValue()->getSExtValue();
  if (cv < 0) {
    llvm_unreachable("unexpected srl value");
  }

  SDLoc dl(Node);
  SDNode *sra =
      CurDAG->getMachineNode(DRAI::ArithS_shr_i32, dl, MVT::i32, input, val);
  SDValue msv = CurDAG->getTargetConstant((~0U >> cv), dl, MVT::i32);
  SDNode *mask = CurDAG->getMachineNode(DRAI::MoveI_move_si, dl, MVT::i32, msv);
  SDNode *res = CurDAG->getMachineNode(DRAI::ArithS_and_i32, dl, MVT::i32,
                                       SDValue(sra, 0), SDValue(mask, 0));

  ReplaceNode(Node, res);
  CurDAG->RemoveDeadNodes();
  return true;
}

bool DRAIDAGToDAGISel::SelectZERO_EXTEND(SDNode *Node) {
  dbgs() << "hit: SelectZERO_EXTEND!!!\n";

  SDValue mask = Node->getOperand(0);
  if (Node->getValueType(0) != Subtarget->Vec(MVT::i32) ||
      mask->getValueType(0) != Subtarget->Vec(MVT::i1)) {
    return false;
  }

  SDLoc dl(Node);

  SDValue truth = CurDAG->getRegister(DRAI::PredTruth, Subtarget->Vec(MVT::i1));
  SDValue undef = SDValue(CurDAG->getMachineNode(TargetOpcode::IMPLICIT_DEF, dl,
                                                 Subtarget->Vec(MVT::i32)),
                          0);

  SDNode *zero =
      CurDAG->getMachineNode(DRAI::MoveI_move_si, dl, MVT::i32,
                             CurDAG->getTargetConstant(0, dl, MVT::i32));
  SDNode *one =
      CurDAG->getMachineNode(DRAI::MoveI_move_si, dl, MVT::i32,
                             CurDAG->getTargetConstant(1, dl, MVT::i32));
  SDNode *zv =
      CurDAG->getMachineNode(DRAI::MoveV_move_vs, dl, Subtarget->Vec(MVT::i32),
                             SDValue(zero, 0), truth, undef);
  SDNode *res =
      CurDAG->getMachineNode(DRAI::MoveV_move_vs, dl, Subtarget->Vec(MVT::i32),
                             SDValue(one, 0), mask, SDValue(zv, 0));

  ReplaceNode(Node, res);
  CurDAG->RemoveDeadNodes();
  return true;
}

bool DRAIDAGToDAGISel::SelectTRUNCATE(SDNode *Node) {
  dbgs() << "hit: SelectTRUNCATE!!!\n";

  SDValue val = Node->getOperand(0);
  if (!(val->getValueType(0) == MVT::i32 && Node->getValueType(0) == MVT::i1) &&
      !(val->getValueType(0) == Subtarget->Vec(MVT::i32) &&
        Node->getValueType(0) == Subtarget->Vec(MVT::i1))) {
    return false;
  }

  SDLoc dl(Node);
  SDNode *one =
      CurDAG->getMachineNode(DRAI::MoveI_move_si, dl, MVT::i32,
                             CurDAG->getTargetConstant(1, dl, MVT::i32));

  SDNode *res = nullptr;
  if (Node->getValueType(0) == MVT::i1) {
    res = CurDAG->getMachineNode(DRAI::ArithS_and_i32, dl,
                                 Node->getValueType(0), val, SDValue(one, 0));
    res = CurDAG->getMachineNode(DRAI::CmpS_eq_i32, dl, Node->getValueType(0),
                                 SDValue(res, 0), SDValue(one, 0));
  } else {
    SDValue truth =
        CurDAG->getRegister(DRAI::PredTruth, Subtarget->Vec(MVT::i1));
    SDValue undef =
        SDValue(CurDAG->getMachineNode(TargetOpcode::IMPLICIT_DEF, dl,
                                       Subtarget->Vec(MVT::i32)),
                0);
    one = CurDAG->getMachineNode(DRAI::MoveV_move_vs, dl,
                                 Subtarget->Vec(MVT::i32), SDValue(one, 0),
                                 truth, undef);

    res = CurDAG->getMachineNode(DRAI::ArithV_and_v_i32, dl,
                                 Node->getValueType(0),
                                 {val, SDValue(one, 0), truth, undef});
    res = CurDAG->getMachineNode(
        DRAI::CmpV_eq_v_i32, dl, Node->getValueType(0),
        {SDValue(res, 0), SDValue(one, 0), truth, undef});
  }

  ReplaceNode(Node, res);
  CurDAG->RemoveDeadNodes();
  return true;
}

void DRAIDAGToDAGISel::Select(SDNode *Node) {
  // Instruction Selection not handled by the auto-generated tablegen selection
  // should be handled here.
  unsigned Opcode = Node->getOpcode();
  bool success = false;

  switch (Opcode) {
  default:
    break;

  // case ISD::Constant: // todo use Pat to improve this
  //   success = SelectConstant(Node);
  //   break;
  // case ISD::ConstantFP: // todo use Pat to improve this
  //   success = SelectConstantFP(Node);
  //   break;
  case ISD::BUILD_VECTOR:
    success = SelectBUILD_VECTOR(Node);
    break;
  /*
    do't support i64 shl
  replacing:
    res = shl input, imm
  with:
    tmp = MoveI_move_ei (1 << imm)
    res = ArithE_mul_i64 input, tmp
  */
  case ISD::SHL:
    success = SelectSHL(Node);
    break;
  /*
    for immediate shift len
  replacing:
    res = srl input, imm
  with:
    tmp = sra input, imm
    res = and tmp, (~0U >> imm)
  */
  case ISD::SRL:
    success = SelectSRL(Node);
    break;
  /*
  replacing:
    v64i32 = zero_extend v64i1:mask
  with:
    zero = MoveI_move_si 0
    one = MoveI_move_si 1
    zv = MoveI_move_vs zero
    res = MoveI_move_vs one, mask, zv
  */
  case ISD::ZERO_EXTEND:
    success = SelectZERO_EXTEND(Node);
    break;
  /*
  replacing:
    i1 = truncate i32:val
  with:
    one = MoveI_move_si 1
    res = CmpS_eq_i32 val, one

  replacing:
    v64i1 = truncate v64i32:val
  with:
    one = MoveI_move_si 1
    vec = MoveI_move_vs one
    res = CmpS_eq_i32 val, vec
  */
  case ISD::TRUNCATE:
    success = SelectTRUNCATE(Node);
    break;
  case ISD::INTRINSIC_W_CHAIN: {
    uint64_t intr_id =
        cast<ConstantSDNode>(Node->getOperand(1))->getZExtValue();
    switch (intr_id) {
    default:
      break;
    };
  } break;
  }

  if (!success) {
    // Select the default instruction.
    SelectCode(Node);
  }
}

// bool DRAIDAGToDAGISel::SelectADDRri(SDValue Addr, SDValue &Base,
//                                     SDValue &Offset) {
//   Base = Addr;
//   Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i32);
//   return true;
// }